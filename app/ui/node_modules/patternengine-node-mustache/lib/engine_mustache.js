/*
 * mustache pattern engine for patternlab-node - v2.X.X - 2016
 *
 * Geoffrey Pursell, Brian Muenzenmeyer, and the web community.
 * Licensed under the MIT license.
 *
 * Many thanks to Brad Frost and Dave Olsen for inspiration, encouragement, and advice.
 *
 */

/*
 * ENGINE SUPPORT LEVEL:
 *
 * Full + extensions. Partial calls and lineage hunting are supported. Style
 * modifiers and pattern parameters are used to extend the core feature set of
 * Mustache templates.
 *
 */

"use strict";

var Hogan = require('hogan.js');
var JSON5 = require('json5');
var utilMustache = require('./util_mustache');

var engine_mustache = {
  engine: Hogan,
  engineName: 'hogan',
  engineFileExtension: '.mustache',

  // partial expansion is only necessary for Mustache templates that have
  // style modifiers or pattern parameters (I think)
  expandPartials: true,

  // regexes, stored here so they're only compiled once
  findPartialsRE: utilMustache.partialsRE,
  findPartialsWithStyleModifiersRE: utilMustache.partialsWithStyleModifiersRE,
  findPartialWithStyleModifiersRE: utilMustache.partialWithStyleModifiersRE,
  findPartialsWithPatternParametersRE: utilMustache.partialsWithPatternParametersRE,
  findPartialKeyRE: utilMustache.partialKeyRE,
  findListItemsRE: utilMustache.listItemsRE,

  stxUnicode: '\u0002',
  etxUnicode: '\u0003',

  escapeReservedRegexChars: function (regexStr) {
    return regexStr.replace(/[.*+?^${}()|[\]\\\/]/g, '\\$&');
  },

  // render it
  renderPattern: function renderPattern(pattern, data, partials) {
    var toRender;

    if (typeof pattern === 'string') {
      toRender = pattern;
    } else if (typeof pattern.extendedTemplate === 'string') {
      toRender = pattern.extendedTemplate;
    } else {
      debugger;
      console.log("e = renderPattern() requires a string or a pattern object as its first argument!");
    }

    try {
      var compiled = Hogan.compile(toRender);

      if (partials) {
        return compiled.render(data, partials);
      }
      return compiled.render(data);
    } catch (e) {
      debugger;
      console.log("e = ", e);
    }
    return undefined;
  },

  /**
   * Find regex matches within both pattern strings and pattern objects.
   *
   * @param {string|object} pattern Either a string or a pattern object.
   * @param {object} regex A JavaScript RegExp object.
   * @returns {array|null} An array if a match is found, null if not.
   */
  patternMatcher: function patternMatcher(pattern, regex) {
    var matches;
    if (typeof pattern === 'string') {
      matches = pattern.match(regex);
    } else if (typeof pattern === 'object' && typeof pattern.extendedTemplate === 'string') {
      matches = pattern.extendedTemplate.match(regex);
    }
    return matches;
  },

  // find and return any {{> template-name }} within pattern
  findPartials: function findPartials(pattern) {
    var matches = this.patternMatcher(pattern, this.findPartialsRE);
    return matches;
  },

  findPartialsWithStyleModifiers: function (pattern) {
    var matches = this.patternMatcher(pattern, this.findPartialsWithStyleModifiersRE);
    return matches;
  },

  // returns any patterns that match {{> value(foo:"bar") }} or {{>
  // value:mod(foo:"bar") }} within the pattern
  findPartialsWithPatternParameters: function (pattern) {
    var matches = this.patternMatcher(pattern, this.findPartialsWithPatternParametersRE);
    return matches;
  },

  // given a pattern, and a partial string, tease out the "pattern key" and
  // return it.
  findPartialKey: function (partialString) {
    var partialKeyArr = partialString.match(this.findPartialKeyRE);
    var partialKey = '';
    if (partialKeyArr && partialKeyArr[1]) {
      partialKey += partialKeyArr[1];
      if (partialKeyArr[2]) {
        partialKey += partialKeyArr[2];
      }
      if (partialKeyArr[3]) {
        partialKey += partialKeyArr[3];
      }
    }
    return partialKey;
  },

  // GTP: the old implementation works better. We might not need
  // this.findPartialRE anymore if it works in all cases!
  findPartial: function (partialString) {
    //strip out the template cruft
    var foundPatternPartial = partialString.replace("{{> ", "").replace(" }}", "").replace("{{>", "").replace("}}", "");

    // remove any potential pattern parameters. this and the above are rather brutish but I didn't want to do a regex at the time
    if (foundPatternPartial.indexOf('(') > 0) {
      foundPatternPartial = foundPatternPartial.substring(0, foundPatternPartial.indexOf('('));
    }

    //remove any potential stylemodifiers.
    foundPatternPartial = foundPatternPartial.split(':')[0];

    return foundPatternPartial;
  },

  findListItems: function (pattern) {
    var matches = this.patternMatcher(pattern, this.findListItemsRE);
    return matches;
  },

  clonePartial: function (partialObj) {
    var partialNew = JSON.parse(JSON.stringify(partialObj));
    var partialRegexes = this.getPartialRegexes(partialNew.key);

    partialNew.partialRegex = partialRegexes.partialRegex;
    partialNew.partialStrEscaped = partialRegexes.partialStrEscaped;
    partialNew.partialRegexEscaped = partialRegexes.partialRegexEscaped;

    return partialNew;
  },

  escapeIncludeTags: function (content, flag) {
    var regex = new RegExp('{{>', flag);
    var contentNew = content.replace(regex, '\u0002>');
    return contentNew;
  },

  unescapeIncludeTags: function (content, flag) {
    var regex = new RegExp('\u0002>', flag);
    var contentNew = content.replace(regex, '{{>');
    return contentNew;
  },

  registerPartial: function (key, pattern, patternlab) {
    var exports = module.exports;
    var i;
    var j;
    var leftParen;
    var rightParen;
    var paramString;
    var params;
    var partial;
    var partialObj;
    var partials = exports.findPartials(pattern);
    var registered;
    var styleModifiers = '';
    var styleModifiersMatches;

    params = null;

    if (patternlab.partials[key]) {
      return;
    }

    // identify and save params submitted with this partial
    leftParen = key.indexOf('(');
    if (leftParen > -1) {
      rightParen = key.lastIndexOf(')');
      paramString = '{' + key.substring(leftParen + 1, rightParen) + '}';
      try {
        params = JSON5.parse(utilMustache.paramToJson(paramString));
      } catch (err) {
        console.error(err);
      }
    }

    styleModifiersMatches = key.match(this.findPartialWithStyleModifiersRE);
    if (Array.isArray(styleModifiersMatches) && styleModifiersMatches[2]) {
      styleModifiers = styleModifiersMatches[2].slice(1).replace(/\|/g, ' ');
    }

    partialObj = patternlab.partials[key] = {
      key: key,
      partial: exports.findPartialKey(key),
      params: params,
      styleModifiers: styleModifiers,
      content: this.renderParams(pattern.template, params).replace(/(>|\})\s+(<|\{)/g, '$1 $2').replace(/\s*\n/g, ''),
      contentRendered: '',
      nestedDataKeys: [],
      nestedPartials: []
    };

    // render styleModifiers
    partialObj.content = partialObj.content.replace(/\{\{\s*styleModifier\s*\}\}/g, styleModifiers || '');

    // escape the parametered tags within partials by changing delimiters to unicodes
    // for start-of-text and end-of-text
    partialObj.nestedDataKeys = partialObj.content.match(/\{\{#[\S\s]+?\}\}/g) || [];
    partialObj.nestedDataKeys = partialObj.nestedDataKeys.concat(partialObj.content.match(/\{\{\^[\S\s]+?\}\}/g) || []);
  },

  renderParams: function (content, params) {
    var i;
    var escapedKey;
    var contentNew = content;
    var regex;

    if (params && Object.keys(params).length) {
      contentNew = '{{=\u0002 \u0003=}}' + contentNew;

      for (i in params) {
        if (params.hasOwnProperty(i)) {
          escapedKey = this.escapeReservedRegexChars(i);

          // apply replacement based on allowable characters from lines 78 and 79 of mustache.js
          // of the Mustache for JS project.
          regex = new RegExp('\\{\\{([\\{#\\^\\/&]?\\s*' + escapedKey + '\\s*)\\}?\\}\\}', 'g');

          contentNew = contentNew.replace(regex, '\u0002$1\u0003');
        }
      }

      // render this pattern immediately, so as to delete blocks not keyed to allData
      contentNew = this.renderPattern(contentNew, params);
    }

    return contentNew;
  },

  winnowPartials: function (content, escapedKeys) {
    var dataKey;
    var dataKeysRegex;
    var i;
    var j;
    var contentNew = content;
    var partialContent;
    var partials;
    var partialsUnique;
    var pMatch;
    var regex;
    var regexStr;
    var tag;
    var tmpPattern;

    //apply replacement based on allowable characters from lines 78 and 79 of mustache.js
    //of the Mustache for JS project.
    dataKeysRegex = new RegExp('\\{\\{([\\{#\\^\\/&]?(\\s*|[^\\}]*\\.)(' + escapedKeys + ')\\s*)\\}\\}', 'g');

    contentNew = contentNew.replace(dataKeysRegex, '\u0002$1}}');

    //removing empty lines reduces rendering time considerably.
    //TODO: do this earlier and only once.
    contentNew = contentNew.replace(/^\s*$\n/gm, '');

    //escape partial includes so they are not erased by a render
    contentNew = this.escapeIncludeTags(contentNew, 'g');

    //render this pattern immediately, so as to delete blocks not keyed to anything in dataKeysRegex
    contentNew = this.renderPattern(contentNew, {});

    //unescape data keys and partial includes
    contentNew = contentNew.replace(/\u0002/g, '{{');

    return contentNew;
  },

  getPartialJustTags: function (content, params) {
    var justTags = '';
    if (/\{\{[\S\s]+?\}\}/.test(content)) {
      justTags = content;
      justTags = justTags.replace(/^[\S\s]*?(\{\{[\S\s]+?\}\})/, '$1');

      // the whitespace between tags is mandatory
      justTags = justTags.replace(/(\}\})[\S\s]*?(\{\{)/g, '$1\n$2');
      justTags = justTags.replace(/^([\S\s]*\}\})([\S\s]*)/, '$1');

      // render params
      if (params) {
        justTags = this.renderParams(justTags, params);
      }
    }
    return justTags;
  }
};

module.exports = engine_mustache;
